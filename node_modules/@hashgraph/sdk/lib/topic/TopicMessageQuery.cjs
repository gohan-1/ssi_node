"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TransactionId = _interopRequireDefault(require("../transaction/TransactionId.cjs"));

var _SubscriptionHandle = _interopRequireDefault(require("./SubscriptionHandle.cjs"));

var _TopicMessage = _interopRequireDefault(require("./TopicMessage.cjs"));

var proto = _interopRequireWildcard(require("@hashgraph/proto"));

var _TopicId = _interopRequireDefault(require("./TopicId.cjs"));

var _long = _interopRequireDefault(require("long"));

var _Timestamp = _interopRequireDefault(require("../Timestamp.cjs"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {import("../channel/Channel.js").default} Channel
 * @typedef {import("../channel/MirrorChannel.js").default} MirrorChannel
 */

/**
 * @template {Channel} ChannelT
 * @typedef {import("../client/Client.js").default<ChannelT, MirrorChannel>} Client<ChannelT, MirrorChannel>
 */
class TopicMessageQuery {
  /**
   * @param {object} props
   * @param {TopicId | string} [props.topicId]
   * @param {Timestamp} [props.startTime]
   * @param {Timestamp} [props.endTime]
   * @param {Long | number} [props.limit]
   */
  constructor(props = {}) {
    /**
     * @private
     * @type {?TopicId}
     */
    this._topicId = null;

    if (props.topicId != null) {
      this.setTopicId(props.topicId);
    }
    /**
     * @private
     * @type {?Timestamp}
     */


    this._startTime = null;

    if (props.startTime != null) {
      this.setStartTime(props.startTime);
    }
    /**
     * @private
     * @type {?Timestamp}
     */


    this._endTime = null;

    if (props.endTime != null) {
      this.setEndTime(props.endTime);
    }
    /**
     * @private
     * @type {?Long}
     */


    this._limit = null;

    if (props.limit != null) {
      this.setLimit(props.limit);
    }
  }
  /**
   * @returns {?TopicId}
   */


  get topicId() {
    return this._topicId;
  }
  /**
   * @param {TopicId | string} topicId
   * @returns {TopicMessageQuery}
   */


  setTopicId(topicId) {
    this._topicId = topicId instanceof _TopicId.default ? topicId : _TopicId.default.fromString(topicId);
    return this;
  }
  /**
   * @returns {?Timestamp}
   */


  get startTime() {
    return this._startTime;
  }
  /**
   * @param {Timestamp | Date | number} startTime
   * @returns {TopicMessageQuery}
   */


  setStartTime(startTime) {
    this._startTime = startTime instanceof _Timestamp.default ? startTime : startTime instanceof Date ? _Timestamp.default.fromDate(startTime) : new _Timestamp.default(startTime, 0);
    return this;
  }
  /**
   * @returns {?Timestamp}
   */


  get endTime() {
    return this._endTime;
  }
  /**
   * @param {Timestamp | Date | number} endTime
   * @returns {TopicMessageQuery}
   */


  setEndTime(endTime) {
    this._endTime = endTime instanceof _Timestamp.default ? endTime : endTime instanceof Date ? _Timestamp.default.fromDate(endTime) : new _Timestamp.default(endTime, 0);
    return this;
  }
  /**
   * @returns {?Long}
   */


  get limit() {
    return this._limit;
  }
  /**
   * @param {Long | number} limit
   * @returns {TopicMessageQuery}
   */


  setLimit(limit) {
    this._limit = limit instanceof _long.default ? limit : _long.default.fromValue(limit);
    return this;
  }
  /**
   * @param {Client<*>} client
   * @param {(message: TopicMessage) => void} listener
   * @returns {SubscriptionHandle}
   */


  subscribe(client, listener) {
    const handle = new _SubscriptionHandle.default();

    this._makeServerStreamRequest(handle, 0, client, listener);

    return handle;
  }
  /**
   * @param {SubscriptionHandle} handle
   * @param {number} attempt
   * @param {import("../client/Client.js").default<Channel, MirrorChannel>} client
   * @param {(message: TopicMessage) => void} listener
   * @returns {void}
   */


  _makeServerStreamRequest(handle, attempt, client, listener) {
    /** @type {Map<string, proto.ConsensusTopicResponse[]>} */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const list = new Map();
    const request = proto.ConsensusTopicQuery.encode({
      topicID: this._topicId != null ? this._topicId._toProtobuf() : null,
      consensusStartTime: this._startTime != null ? this._startTime._toProtobuf() : null,
      consensusEndTime: this._endTime != null ? this._endTime._toProtobuf() : null,
      limit: this._limit != null ? this._limit : null
    }).finish();

    const cancel = client._mirrorNetwork.getNextMirrorNode().channel.makeServerStreamRequest(request, (error, data) => {
      if (data == null || error != null) {
        // NOT_FOUND or UNAVAILABLE
        if (attempt < 10 && (error === 5 || error === 14)) {
          setTimeout(() => {
            this._makeServerStreamRequest(handle, attempt + 1, client, listener);
          }, 250 * 2 ** attempt);
        }

        return;
      }

      const message = proto.ConsensusTopicResponse.decode(data);

      if (message.chunkInfo == null) {
        listener(_TopicMessage.default._ofSingle(message));
      } else {
        const chunkInfo =
        /** @type {proto.IConsensusMessageChunkInfo} */
        message.chunkInfo;
        const initialTransactionID =
        /** @type {proto.ITransactionID} */
        chunkInfo.initialTransactionID;
        const total =
        /** @type {number} */
        chunkInfo.total;

        const transactionId = _TransactionId.default._fromProtobuf(initialTransactionID).toString();
        /** @type {proto.ConsensusTopicResponse[]} */


        let responses = [];
        const temp = list.get(transactionId);

        if (temp == null) {
          list.set(transactionId, responses);
        } else {
          responses = temp;
        }

        responses.push(message);

        if (responses.length === total) {
          list.delete(transactionId);
          listener(_TopicMessage.default._ofMany(responses));
        }
      }
    });

    handle._setCall(() => cancel());
  }

}

exports.default = TopicMessageQuery;